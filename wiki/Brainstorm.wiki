#Brainstorm ideas for v8cgi

= Introduction =

This page to document ideas to implement in v8cgi.


== Error Handling ==

=== The situation ===

Currently, v8cgi simply shows a 500 page if there's any errors in the javascript.

I noticed that if a try/catch is put around the code, you can catch all errors!

=== Resolution ===

I suggest that the through some mechanism, a try/catch is automatically inserted around the main javascript file to be executed.  The catch block would invoke a default onError() handler that would print a nice error page.  If v8cgi is configured for "production" mode, the error page would be something like the current 500 page (apache's).  If not, then the error page could dump out the exception.

Note that code can throw two ways:

  * throw "some message";
  * throw new Error("some message");

*If the second is thrown, then a javascript stack trace is available to the error handler!*

Thus, v8cgi source should be examined and the second type of exception thrown anywhere an exception is currently thrown (may already be the case).

The application should be able to provide its own error handler.

== Output Buffering ==

=== The situation ===

The response object has no concept of output buffering.  The concept is similar to PHP's:
  * ob_start()
  * ob_get_contents()
  * ob_end_clean()
  * ob_end_flush()

Using this scheme allows the server to know content-length, and allows error handlers to do an ob_end_clean() and then print a nice error page.

=== Resolution ===

ob_start() should be done automatically at script start.  ob_end_flush() should be done automatically right at script exit.

== Application-Wide Session ==

=== The situation ===

For lack of a better description, this is a hash array stored in memory.  All v8cgi threads running can store to this hash array, any javascript object.

The API might look like:

  * system.shared.get(key)
  * system.shared.put(key, obj)
  * system.shared.lock(type) // type is one of read or write
  * system.shared.unlock()

Note that the lock must be cleared onexit().

We have sockets.  Consider code like this:
{{{
 var socket = socket.open(...);
 var cacheable = { type: 'aim', socket: socket };
 system.shared.put('aimsocket', cacheable);
}}}

You can't serialize and write an open socket to a file on disk!

